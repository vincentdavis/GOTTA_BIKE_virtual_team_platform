"""Views for team app."""

import uuid

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.db.models import Q
from django.http import HttpRequest, HttpResponse
from django.shortcuts import get_object_or_404, redirect, render
from django.utils import timezone
from django.views.decorators.http import require_GET, require_http_methods, require_POST

from apps.accounts.decorators import team_member_required
from apps.accounts.discord_service import send_verification_notification
from apps.accounts.models import User
from apps.team.forms import TeamLinkEditForm, TeamLinkForm
from apps.team.models import RaceReadyRecord, RosterFilter, TeamLink
from apps.team.services import ZP_DIV_TO_CATEGORY, get_performance_review_data, get_unified_team_roster
from apps.zwiftpower.models import ZPTeamRiders


@login_required
@team_member_required()
@require_GET
def team_roster_view(request: HttpRequest) -> HttpResponse:
    """Display unified team roster.

    Args:
        request: The HTTP request.

    Returns:
        Rendered team roster page.

    """
    roster = get_unified_team_roster()

    # Get filter parameters
    search_query = request.GET.get("q", "").strip()
    zp_category_filter = request.GET.get("zp_category", "")
    zr_category_filter = request.GET.get("zr_category", "")
    status_filter = request.GET.get("status", "active")  # Default to showing active members
    gender_filter = request.GET.get("gender", "")
    race_ready_filter = request.GET.get("race_ready", "")

    # Get sort parameters (default: result_count descending)
    sort_by = request.GET.get("sort", "results")
    sort_dir = request.GET.get("dir", "desc")

    # Collect unique values for filter dropdowns (before filtering)
    # For ZP categories, use the mapping to show letters
    zp_divs_present = sorted({r.zp_div for r in roster if r.in_zwiftpower and r.zp_div})
    zp_categories = [(div, ZP_DIV_TO_CATEGORY.get(div, str(div))) for div in zp_divs_present]
    zr_categories = sorted({r.zr_category for r in roster if r.in_zwiftracing and r.zr_category})

    # Apply status filter
    if status_filter == "active":
        roster = [r for r in roster if r.is_active_member]
    elif status_filter in ("both", "zp_only", "zr_only", "left", "none"):
        roster = [r for r in roster if r.membership_status == status_filter]

    # Apply search filter (by zwid or name)
    if search_query:
        search_lower = search_query.lower()
        roster = [
            r for r in roster
            if search_lower in r.display_name.lower() or search_query in str(r.zwid)
        ]

    # Apply ZwiftPower category filter (filter by div number)
    if zp_category_filter:
        try:
            div_value = int(zp_category_filter)
            roster = [r for r in roster if r.in_zwiftpower and r.zp_div == div_value]
        except ValueError:
            pass

    # Apply Zwift Racing category filter
    if zr_category_filter:
        roster = [r for r in roster if r.in_zwiftracing and r.zr_category == zr_category_filter]

    # Apply gender filter
    if gender_filter:
        roster = [r for r in roster if r.gender == gender_filter]

    # Apply race ready filter
    if race_ready_filter:
        if race_ready_filter == "yes":
            roster = [r for r in roster if r.is_race_ready]
        elif race_ready_filter == "no":
            roster = [r for r in roster if not r.is_race_ready]

    # Apply sorting
    reverse = sort_dir == "desc"
    sort_keys = {
        "name": lambda r: r.display_name.lower(),
        "zwid": lambda r: r.zwid,
        "gender": lambda r: r.gender or "",
        "account": lambda r: r.has_account,
        "verified": lambda r: r.zwid_verified,
        "race_ready": lambda r: r.is_race_ready,
        "category": lambda r: r.zp_div or 0,
        "catw": lambda r: r.zp_divw or 0,
        "rating": lambda r: r.zr_category or "",
        "results": lambda r: r.result_count,
    }
    if sort_by in sort_keys:
        roster = sorted(roster, key=sort_keys[sort_by], reverse=reverse)

    return render(
        request,
        "team/roster.html",
        {
            "roster": roster,
            "search_query": search_query,
            "zp_category_filter": zp_category_filter,
            "zr_category_filter": zr_category_filter,
            "status_filter": status_filter,
            "gender_filter": gender_filter,
            "race_ready_filter": race_ready_filter,
            "zp_categories": zp_categories,
            "zr_categories": zr_categories,
            "sort_by": sort_by,
            "sort_dir": sort_dir,
        },
    )


@require_GET
def filtered_roster_view(request: HttpRequest, filter_id: uuid.UUID) -> HttpResponse:
    """Display filtered team roster based on Discord channel members.

    This view does not require login - it's accessed via time-limited links
    generated by the Discord bot /in_channel command.

    Args:
        request: The HTTP request.
        filter_id: UUID of the RosterFilter record.

    Returns:
        Rendered filtered team roster page or 404 if filter not found/expired.

    """
    # Get the filter, return 404 if not found
    roster_filter = get_object_or_404(RosterFilter, id=filter_id)

    # Check if filter has expired
    if roster_filter.is_expired:
        return render(
            request,
            "team/roster_filter_expired.html",
            {"filter": roster_filter},
            status=410,  # Gone
        )

    # Get full roster
    roster = get_unified_team_roster()

    # Filter to only users whose discord_id is in the filter's discord_ids list
    # Convert discord_ids to strings for comparison
    discord_id_set = {str(did) for did in roster_filter.discord_ids}

    # Import User model to look up discord_ids
    from apps.accounts.models import User

    # Get user_ids that match the discord_ids
    matching_user_ids = set(
        User.objects.filter(discord_id__in=discord_id_set).values_list("id", flat=True)
    )

    # Filter roster to only include riders with matching user accounts
    roster = [r for r in roster if r.user_id and r.user_id in matching_user_ids]

    # Get sort parameters (default: name ascending for filtered view)
    sort_by = request.GET.get("sort", "name")
    sort_dir = request.GET.get("dir", "asc")

    # Apply sorting
    reverse = sort_dir == "desc"
    sort_keys = {
        "name": lambda r: r.display_name.lower(),
        "zwid": lambda r: r.zwid,
        "gender": lambda r: r.gender or "",
        "account": lambda r: r.has_account,
        "verified": lambda r: r.zwid_verified,
        "race_ready": lambda r: r.is_race_ready,
        "category": lambda r: r.zp_div or 0,
        "catw": lambda r: r.zp_divw or 0,
        "rating": lambda r: r.zr_category or "",
        "results": lambda r: r.result_count,
    }
    if sort_by in sort_keys:
        roster = sorted(roster, key=sort_keys[sort_by], reverse=reverse)

    # Collect unique values for filter dropdowns
    zp_divs_present = sorted({r.zp_div for r in roster if r.in_zwiftpower and r.zp_div})
    zp_categories = [(div, ZP_DIV_TO_CATEGORY.get(div, str(div))) for div in zp_divs_present]
    zr_categories = sorted({r.zr_category for r in roster if r.in_zwiftracing and r.zr_category})

    return render(
        request,
        "team/roster.html",
        {
            "roster": roster,
            "roster_filter": roster_filter,
            "search_query": "",
            "zp_category_filter": "",
            "zr_category_filter": "",
            "status_filter": "",
            "gender_filter": "",
            "race_ready_filter": "",
            "zp_categories": zp_categories,
            "zr_categories": zr_categories,
            "sort_by": sort_by,
            "sort_dir": sort_dir,
        },
    )


@login_required
@team_member_required()
@require_GET
def team_links_view(request: HttpRequest) -> HttpResponse:
    """Display team links with filtering.

    Args:
        request: The HTTP request.

    Returns:
        Rendered team links page.

    """
    now = timezone.now()
    # Filter links that are currently visible:
    # - active=True
    # - date_open is null OR date_open <= now
    # - date_closed is null OR date_closed > now
    links = TeamLink.objects.filter(
        active=True,
    ).filter(
        Q(date_open__isnull=True) | Q(date_open__lte=now),
    ).filter(
        Q(date_closed__isnull=True) | Q(date_closed__gt=now),
    )

    # Get filter parameters
    search_query = request.GET.get("q", "").strip()
    type_filter = request.GET.get("type", "")

    # Get all available types for filter dropdown
    available_types = TeamLink.LinkType.choices

    # Apply search filter
    if search_query:
        search_lower = search_query.lower()
        links = links.filter(title__icontains=search_lower) | links.filter(description__icontains=search_lower)

    # Apply type filter
    if type_filter:
        links = links.filter(link_types__contains=type_filter)

    # Check if user can edit links
    can_edit_links = request.user.is_link_admin or request.user.is_superuser

    return render(
        request,
        "team/links.html",
        {
            "links": links,
            "search_query": search_query,
            "type_filter": type_filter,
            "available_types": available_types,
            "can_edit_links": can_edit_links,
        },
    )


@login_required
@team_member_required()
@require_http_methods(["GET", "POST"])
def submit_team_link_view(request: HttpRequest) -> HttpResponse:
    """Submit a new team link.

    Args:
        request: The HTTP request.

    Returns:
        Rendered form or redirect on success.

    """
    # Check if user has permission to create links
    if not request.user.is_link_admin and not request.user.is_superuser:
        messages.error(request, "You don't have permission to create team links.")
        return redirect("team:links")

    if request.method == "POST":
        form = TeamLinkForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, "Team link submitted successfully!")
            return redirect("team:links")
    else:
        form = TeamLinkForm()

    return render(
        request,
        "team/submit_link.html",
        {"form": form},
    )


@login_required
@team_member_required()
@require_http_methods(["GET", "POST"])
def edit_team_link_view(request: HttpRequest, pk: int) -> HttpResponse:
    """Edit an existing team link.

    Args:
        request: The HTTP request.
        pk: The primary key of the TeamLink to edit.

    Returns:
        Rendered form or redirect on success.

    """
    link = get_object_or_404(TeamLink, pk=pk)

    # Check if user has permission to edit
    if not request.user.is_link_admin and not request.user.is_superuser:
        messages.error(request, "You don't have permission to edit team links.")
        return redirect("team:links")

    if request.method == "POST":
        form = TeamLinkEditForm(request.POST, instance=link)
        if form.is_valid():
            form.save()
            messages.success(request, "Team link updated successfully!")
            return redirect("team:links")
    else:
        form = TeamLinkEditForm(instance=link)

    return render(
        request,
        "team/edit_link.html",
        {"form": form, "link": link},
    )


@login_required
@team_member_required()
@require_POST
def delete_team_link_view(request: HttpRequest, pk: int) -> HttpResponse:
    """Delete a team link.

    Args:
        request: The HTTP request.
        pk: The primary key of the TeamLink to delete.

    Returns:
        Redirect to links list.

    """
    link = get_object_or_404(TeamLink, pk=pk)

    # Check if user has permission to delete
    if not request.user.is_link_admin and not request.user.is_superuser:
        messages.error(request, "You don't have permission to delete team links.")
        return redirect("team:links")

    link.delete()
    messages.success(request, "Team link deleted successfully!")
    return redirect("team:links")


@login_required
@team_member_required()
@require_GET
def verification_records_view(request: HttpRequest) -> HttpResponse:
    """Display verification records for team captains.

    Args:
        request: The HTTP request.

    Returns:
        Rendered verification records page.

    """
    # Check if user can view/approve verification records
    if not request.user.can_approve_verification and not request.user.is_superuser:
        messages.error(request, "You don't have permission to view verification records.")
        return redirect("home")

    records = RaceReadyRecord.objects.select_related("user", "reviewed_by").order_by("-date_created")

    # Get filter parameters
    search_query = request.GET.get("q", "").strip()
    type_filter = request.GET.get("type", "")
    status_filter = request.GET.get("status", "")
    gender_filter = request.GET.get("gender", "")

    # Get choices for filter dropdowns
    verify_type_choices = RaceReadyRecord._meta.get_field("verify_type").choices
    status_choices = RaceReadyRecord.Status.choices
    gender_choices = User.Gender.choices

    # Apply search filter (by username or discord_username)
    if search_query:
        records = records.filter(
            Q(user__username__icontains=search_query) | Q(user__discord_username__icontains=search_query)
        )

    # Apply type filter
    if type_filter:
        records = records.filter(verify_type=type_filter)

    # Apply status filter
    if status_filter:
        records = records.filter(status=status_filter)

    # Apply gender filter
    if gender_filter:
        records = records.filter(user__gender=gender_filter)

    # Check if user can verify records (has permission)
    can_verify = request.user.can_approve_verification or request.user.is_superuser

    # Add can_review flag to each record based on same_gender preference
    def user_can_review_record(record: RaceReadyRecord) -> bool:
        """Check if the current user can review a specific record.

        Superusers can always review. If same_gender is False, anyone with
        permission can review. If same_gender is True, only same-gender
        reviewers can review.

        Returns:
            True if the user can review this record, False otherwise.

        """
        if request.user.is_superuser:
            return True
        if not record.same_gender:
            return True
        return record.user.gender == request.user.gender

    # Create list of (record, can_review) tuples for template
    records_with_review_status = [(record, user_can_review_record(record)) for record in records]

    return render(
        request,
        "team/verification_records.html",
        {
            "records_with_review_status": records_with_review_status,
            "search_query": search_query,
            "type_filter": type_filter,
            "status_filter": status_filter,
            "gender_filter": gender_filter,
            "verify_type_choices": verify_type_choices,
            "status_choices": status_choices,
            "gender_choices": gender_choices,
            "can_verify": can_verify,
        },
    )


@login_required
@team_member_required()
@require_http_methods(["GET", "POST"])
def verification_record_detail_view(request: HttpRequest, pk: int) -> HttpResponse:
    """Display and verify or reject a verification record.

    Args:
        request: The HTTP request.
        pk: The primary key of the RaceReadyRecord.

    Returns:
        Rendered record detail page.

    """
    # Check if user can view/approve verification records
    if not request.user.can_approve_verification and not request.user.is_superuser:
        messages.error(request, "You don't have permission to view verification records.")
        return redirect("home")

    record = get_object_or_404(RaceReadyRecord.objects.select_related("user", "reviewed_by"), pk=pk)

    # Check if user can verify records (has permission)
    has_permission = request.user.can_approve_verification or request.user.is_superuser

    # Check same_gender restriction: if set, only same-gender reviewers can access (superusers bypass)
    if record.same_gender and not request.user.is_superuser and record.user.gender != request.user.gender:
        messages.warning(request, "This record requires a same-gender reviewer.")
        return redirect("team:verification_records")

    # User can review if they have permission and pass same_gender check (already checked above)
    can_review = has_permission

    if request.method == "POST" and can_review and record.is_pending:
        action = request.POST.get("action")
        if action == "verify":
            # Prevent self-approval
            if record.user == request.user:
                messages.error(request, "You cannot approve your own verification record.")
                return redirect("team:verification_record_detail", pk=pk)
            record.status = RaceReadyRecord.Status.VERIFIED
            record.reviewed_by = request.user
            record.reviewed_date = timezone.now()
            record.save()
            # Send Discord DM notification
            if record.user.discord_id:
                send_verification_notification(
                    discord_id=record.user.discord_id,
                    is_verified=True,
                    verify_type=record.verify_type,
                )
            messages.success(request, f"Record for {record.user.username} has been verified.")
        elif action == "reject":
            record.status = RaceReadyRecord.Status.REJECTED
            record.reviewed_by = request.user
            record.reviewed_date = timezone.now()
            rejection_reason = request.POST.get("rejection_reason", "").strip()
            record.rejection_reason = rejection_reason
            record.save()
            # Send Discord DM notification
            if record.user.discord_id:
                send_verification_notification(
                    discord_id=record.user.discord_id,
                    is_verified=False,
                    verify_type=record.verify_type,
                    rejection_reason=rejection_reason or None,
                )
            messages.warning(request, f"Record for {record.user.username} has been rejected.")
        return redirect("team:verification_records")

    # Get ZwiftPower data for the user if they have a zwid
    zp_rider = None
    if record.user.zwid:
        zp_rider = ZPTeamRiders.objects.filter(zwid=record.user.zwid).first()

    return render(
        request,
        "team/verification_record_detail.html",
        {
            "record": record,
            "can_review": can_review,
            "zp_rider": zp_rider,
        },
    )


@login_required
@team_member_required()
@require_POST
def delete_expired_media_view(request: HttpRequest) -> HttpResponse:
    """Delete media files and URLs from expired verification records.

    Args:
        request: The HTTP request.

    Returns:
        Redirect to verification records list.

    """
    if not request.user.can_approve_verification and not request.user.is_superuser:
        messages.error(request, "You don't have permission to perform this action.")
        return redirect("team:verification_records")

    # Get all verified records and filter to expired ones
    records = RaceReadyRecord.objects.filter(status=RaceReadyRecord.Status.VERIFIED)
    expired_records = [r for r in records if r.is_expired]

    deleted_count = 0
    for record in expired_records:
        has_media = record.media_file or record.url
        if has_media:
            record.delete_media_file()
            record.url = ""
            record.save(update_fields=["url"])
            deleted_count += 1

    if deleted_count:
        messages.success(request, f"Deleted media from {deleted_count} expired record(s).")
    else:
        messages.info(request, "No expired records with media found.")

    return redirect("team:verification_records")


@login_required
@team_member_required()
@require_POST
def delete_rejected_media_view(request: HttpRequest) -> HttpResponse:
    """Delete media files and URLs from rejected records older than 30 days.

    Args:
        request: The HTTP request.

    Returns:
        Redirect to verification records list.

    """
    from datetime import timedelta

    if not request.user.can_approve_verification and not request.user.is_superuser:
        messages.error(request, "You don't have permission to perform this action.")
        return redirect("team:verification_records")

    # Get rejected records older than 30 days
    cutoff_date = timezone.now() - timedelta(days=30)
    records = RaceReadyRecord.objects.filter(
        status=RaceReadyRecord.Status.REJECTED,
        reviewed_date__lt=cutoff_date,
    )

    deleted_count = 0
    for record in records:
        has_media = record.media_file or record.url
        if has_media:
            record.delete_media_file()
            record.url = ""
            record.save(update_fields=["url"])
            deleted_count += 1

    if deleted_count:
        messages.success(request, f"Deleted media from {deleted_count} rejected record(s).")
    else:
        messages.info(request, "No rejected records older than 30 days with media found.")

    return redirect("team:verification_records")


@login_required
@team_member_required()
@require_GET
def youtube_channels_view(request: HttpRequest) -> HttpResponse:
    """Display list of team members with YouTube channels.

    Args:
        request: The HTTP request.

    Returns:
        Rendered YouTube channels page.

    """
    from apps.accounts.models import User

    # Get users with YouTube channels, ordered by name
    users_with_channels = (
        User.objects.filter(youtube_channel__isnull=False)
        .exclude(youtube_channel="")
        .order_by("first_name", "last_name", "discord_nickname")
    )

    return render(
        request,
        "team/youtube_channels.html",
        {
            "users": users_with_channels,
        },
    )


@login_required
@team_member_required()
@require_GET
def performance_review_view(request: HttpRequest) -> HttpResponse:
    """Display performance review comparing verification records with ZwiftPower data.

    Args:
        request: The HTTP request.

    Returns:
        Rendered performance review page.

    """
    # Check permission - only verification reviewers can access
    if not request.user.can_approve_verification and not request.user.is_superuser:
        messages.error(request, "You don't have permission to view performance review.")
        return redirect("home")

    # Get performance data
    riders = get_performance_review_data()

    # Get filter parameters
    search_query = request.GET.get("q", "").strip()
    zp_category_filter = request.GET.get("zp_category", "")
    gender_filter = request.GET.get("gender", "")

    # Get sort parameters (default: weight_diff descending - largest concerns first)
    sort_by = request.GET.get("sort", "weight_diff")
    sort_dir = request.GET.get("dir", "desc")

    # Collect unique values for filter dropdowns (before filtering)
    zp_divs_present = sorted({r.zp_div for r in riders if r.zp_div})
    zp_categories = [(div, ZP_DIV_TO_CATEGORY.get(div, str(div))) for div in zp_divs_present]

    # Apply search filter (by name or zwid)
    if search_query:
        search_lower = search_query.lower()
        riders = [
            r for r in riders
            if search_lower in r.display_name.lower() or search_query in str(r.zwid)
        ]

    # Apply ZwiftPower category filter
    if zp_category_filter:
        try:
            div_value = int(zp_category_filter)
            riders = [r for r in riders if r.zp_div == div_value]
        except ValueError:
            pass

    # Apply gender filter
    if gender_filter:
        riders = [r for r in riders if r.gender == gender_filter]

    # Apply sorting
    reverse = sort_dir == "desc"
    sort_keys = {
        "name": lambda r: r.display_name.lower(),
        "weight_diff": lambda r: r.weight_diff_abs if r.weight_diff_abs is not None else -1,
        "weight_light_date": lambda r: r.weight_light_date or timezone.datetime.min.replace(tzinfo=timezone.utc),
        "weight_full_date": lambda r: r.weight_full_date or timezone.datetime.min.replace(tzinfo=timezone.utc),
        "height_date": lambda r: r.height_date or timezone.datetime.min.replace(tzinfo=timezone.utc),
        "zp_result_date": lambda r: r.zp_result_date or timezone.datetime.min.replace(tzinfo=timezone.utc),
        "zp_height_date": lambda r: r.zp_height_date or timezone.datetime.min.replace(tzinfo=timezone.utc),
    }
    if sort_by in sort_keys:
        riders = sorted(riders, key=sort_keys[sort_by], reverse=reverse)

    return render(
        request,
        "team/performance_review.html",
        {
            "riders": riders,
            "search_query": search_query,
            "zp_category_filter": zp_category_filter,
            "gender_filter": gender_filter,
            "zp_categories": zp_categories,
            "sort_by": sort_by,
            "sort_dir": sort_dir,
        },
    )
